/*
Copyright 2019 The Cloud-Barista Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Package mcir is to manage multi-cloud infra resource
package mcir

import (
	"encoding/json"
	"fmt"
	"os"
	"sort"
	"strconv"
	"strings"

	//"strings"

	"github.com/cloud-barista/cb-spider/interface/api"
	"github.com/cloud-barista/cb-tumblebug/src/core/common"
	validator "github.com/go-playground/validator/v10"
	"github.com/go-resty/resty/v2"

	//"github.com/cloud-barista/cb-tumblebug/src/core/mcis"

	_ "github.com/go-sql-driver/mysql"
)

type SpiderSpecInfo struct { // Spider
	// https://github.com/cloud-barista/cb-spider/blob/master/cloud-control-manager/cloud-driver/interfaces/resources/VMSpecHandler.go

	Region string
	Name   string
	VCpu   SpiderVCpuInfo
	Mem    string
	Gpu    []SpiderGpuInfo

	KeyValueList []common.KeyValue
}

type SpiderVCpuInfo struct { // Spider
	Count string
	Clock string // GHz
}

type SpiderGpuInfo struct { // Spider
	Count string
	Mfr   string
	Model string
	Mem   string
}

type TbSpecReq struct { // Tumblebug
	Name           string `json:"name" validate:"required"`
	ConnectionName string `json:"connectionName" validate:"required"`
	CspSpecName    string `json:"cspSpecName" validate:"required"`
	Description    string `json:"description"`
}

func TbSpecReqStructLevelValidation(sl validator.StructLevel) {

	u := sl.Current().Interface().(TbSpecReq)

	err := common.CheckString(u.Name)
	if err != nil {
		// ReportError(field interface{}, fieldName, structFieldName, tag, param string)
		sl.ReportError(u.Name, "name", "Name", "NotObeyingNamingConvention", "")
	}
}

type TbSpecInfo struct { // Tumblebug
	Namespace             string   `json:"namespace,omitempty"` // required to save in RDB
	Id                    string   `json:"id,omitempty"`
	Name                  string   `json:"name,omitempty"`
	ConnectionName        string   `json:"connectionName,omitempty"`
	CspSpecName           string   `json:"cspSpecName,omitempty"`
	OsType                string   `json:"osType,omitempty"`
	NumvCPU               uint16   `json:"numvCPU,omitempty"`
	NumCore               uint16   `json:"numCore,omitempty"`
	MemGiB                float32  `json:"memGiB,omitempty"`
	StorageGiB            uint32   `json:"storageGiB,omitempty"`
	Description           string   `json:"description,omitempty"`
	CostPerHour           float32  `json:"costPerHour,omitempty"`
	NumStorage            uint8    `json:"numStorage,omitempty"`
	MaxNumStorage         uint8    `json:"maxNumStorage,omitempty"`
	MaxTotalStorageTiB    uint16   `json:"maxTotalStorageTiB,omitempty"`
	NetBwGbps             uint16   `json:"netBwGbps,omitempty"`
	EbsBwMbps             uint32   `json:"ebsBwMbps,omitempty"`
	GpuModel              string   `json:"gpuModel,omitempty"`
	NumGpu                uint8    `json:"numGpu,omitempty"`
	GpuMemGiB             float32  `json:"gpuMemGiB,omitempty"`
	GpuP2p                string   `json:"gpuP2p,omitempty"`
	OrderInFilteredResult uint16   `json:"orderInFilteredResult,omitempty"`
	EvaluationStatus      string   `json:"evaluationStatus,omitempty"`
	EvaluationScore01     float32  `json:"evaluationScore01,omitempty"`
	EvaluationScore02     float32  `json:"evaluationScore02,omitempty"`
	EvaluationScore03     float32  `json:"evaluationScore03,omitempty"`
	EvaluationScore04     float32  `json:"evaluationScore04,omitempty"`
	EvaluationScore05     float32  `json:"evaluationScore05,omitempty"`
	EvaluationScore06     float32  `json:"evaluationScore06,omitempty"`
	EvaluationScore07     float32  `json:"evaluationScore07,omitempty"`
	EvaluationScore08     float32  `json:"evaluationScore08,omitempty"`
	EvaluationScore09     float32  `json:"evaluationScore09,omitempty"`
	EvaluationScore10     float32  `json:"evaluationScore10,omitempty"`
	AssociatedObjectList  []string `json:"associatedObjectList,omitempty"`
	IsAutoGenerated       bool     `json:"isAutoGenerated,omitempty"`
}

// ConvertSpiderSpecToTumblebugSpec accepts an Spider spec object, converts to and returns an TB spec object
func ConvertSpiderSpecToTumblebugSpec(spiderSpec SpiderSpecInfo) (TbSpecInfo, error) {
	if spiderSpec.Name == "" {
		err := fmt.Errorf("ConvertSpiderSpecToTumblebugSpec failed; spiderSpec.Name == \"\" ")
		emptyTumblebugSpec := TbSpecInfo{}
		return emptyTumblebugSpec, err
	}

	tumblebugSpec := TbSpecInfo{}

	tumblebugSpec.Name = spiderSpec.Name
	tumblebugSpec.CspSpecName = spiderSpec.Name
	tempUint64, _ := strconv.ParseUint(spiderSpec.VCpu.Count, 10, 16)
	tumblebugSpec.NumvCPU = uint16(tempUint64)
	tempFloat64, _ := strconv.ParseFloat(spiderSpec.Mem, 32)
	tumblebugSpec.MemGiB = float32(tempFloat64 / 1024) //fmt.Sprintf("%.0f", tempFloat64/1024)

	return tumblebugSpec, nil
}

type SpiderSpecList struct {
	Vmspec []SpiderSpecInfo `json:"vmspec"`
}

// LookupSpecList accepts Spider conn config,
// lookups and returns the list of all specs in the region of conn config
// in the form of the list of Spider spec objects
func LookupSpecList(connConfig string) (SpiderSpecList, error) {

	if connConfig == "" {
		content := SpiderSpecList{}
		err := fmt.Errorf("LookupSpec() called with empty connConfig.")
		common.CBLog.Error(err)
		return content, err
	}

	if os.Getenv("SPIDER_CALL_METHOD") == "REST" {

		url := common.SpiderRestUrl + "/vmspec"

		// Create Req body
		tempReq := common.SpiderConnectionName{}
		tempReq.ConnectionName = connConfig

		client := resty.New().SetCloseConnection(true)
		client.SetAllowGetMethodPayload(true)

		resp, err := client.R().
			SetHeader("Content-Type", "application/json").
			SetBody(tempReq).
			SetResult(&SpiderSpecList{}). // or SetResult(AuthSuccess{}).
			//SetError(&AuthError{}).       // or SetError(AuthError{}).
			Get(url)

		if err != nil {
			common.CBLog.Error(err)
			content := SpiderSpecList{}
			err := fmt.Errorf("an error occurred while requesting to CB-Spider")
			return content, err
		}

		fmt.Println(string(resp.Body()))

		fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
		switch {
		case resp.StatusCode() >= 400 || resp.StatusCode() < 200:
			err := fmt.Errorf(string(resp.Body()))
			common.CBLog.Error(err)
			content := SpiderSpecList{}
			return content, err
		}

		temp := resp.Result().(*SpiderSpecList)
		return *temp, nil

	} else {

		// Set CCM gRPC API
		ccm := api.NewCloudResourceHandler()
		err := ccm.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
		if err != nil {
			common.CBLog.Error("ccm failed to set config : ", err)
			return SpiderSpecList{}, err
		}
		err = ccm.Open()
		if err != nil {
			common.CBLog.Error("ccm api open failed : ", err)
			return SpiderSpecList{}, err
		}
		defer ccm.Close()

		result, err := ccm.ListVMSpecByParam(connConfig)
		if err != nil {
			common.CBLog.Error(err)
			return SpiderSpecList{}, err
		}

		temp := SpiderSpecList{}
		err = json.Unmarshal([]byte(result), &temp)
		if err != nil {
			common.CBLog.Error(err)
			return SpiderSpecList{}, err
		}
		return temp, nil

	}
}

// LookupSpec accepts Spider conn config and CSP spec name, lookups and returns the Spider spec object
func LookupSpec(connConfig string, specName string) (SpiderSpecInfo, error) {

	if connConfig == "" {
		content := SpiderSpecInfo{}
		err := fmt.Errorf("LookupSpec() called with empty connConfig.")
		common.CBLog.Error(err)
		return content, err
	} else if specName == "" {
		content := SpiderSpecInfo{}
		err := fmt.Errorf("LookupSpec() called with empty specName.")
		common.CBLog.Error(err)
		return content, err
	}

	if os.Getenv("SPIDER_CALL_METHOD") == "REST" {

		//url := common.SPIDER_REST_URL + "/vmspec/" + u.CspSpecName
		url := common.SpiderRestUrl + "/vmspec/" + specName

		// Create Req body
		tempReq := common.SpiderConnectionName{}
		tempReq.ConnectionName = connConfig

		client := resty.New().SetCloseConnection(true)
		client.SetAllowGetMethodPayload(true)

		resp, err := client.R().
			SetHeader("Content-Type", "application/json").
			SetBody(tempReq).
			SetResult(&SpiderSpecInfo{}). // or SetResult(AuthSuccess{}).
			//SetError(&AuthError{}).       // or SetError(AuthError{}).
			Get(url)

		if err != nil {
			common.CBLog.Error(err)
			content := SpiderSpecInfo{}
			err := fmt.Errorf("an error occurred while requesting to CB-Spider")
			return content, err
		}

		fmt.Println(string(resp.Body()))

		fmt.Println("HTTP Status code: " + strconv.Itoa(resp.StatusCode()))
		switch {
		case resp.StatusCode() >= 400 || resp.StatusCode() < 200:
			err := fmt.Errorf(string(resp.Body()))
			common.CBLog.Error(err)
			content := SpiderSpecInfo{}
			return content, err
		}

		temp := resp.Result().(*SpiderSpecInfo)
		return *temp, nil

	} else {

		// Set CCM gRPC API
		ccm := api.NewCloudResourceHandler()
		err := ccm.SetConfigPath(os.Getenv("CBTUMBLEBUG_ROOT") + "/conf/grpc_conf.yaml")
		if err != nil {
			common.CBLog.Error("ccm failed to set config : ", err)
			return SpiderSpecInfo{}, err
		}
		err = ccm.Open()
		if err != nil {
			common.CBLog.Error("ccm api open failed : ", err)
			return SpiderSpecInfo{}, err
		}
		defer ccm.Close()

		result, err := ccm.GetVMSpecByParam(connConfig, specName)
		if err != nil {
			common.CBLog.Error(err)
			return SpiderSpecInfo{}, err
		}

		temp := SpiderSpecInfo{}
		err2 := json.Unmarshal([]byte(result), &temp)
		if err2 != nil {
			fmt.Errorf("an error occurred while unmarshaling: " + err2.Error())
		}
		return temp, nil

	}
}

func RefineSpecName(specName string) string {
	out := strings.ToLower(specName)
	out = strings.ReplaceAll(out, ".", "-")
	out = strings.ReplaceAll(out, "_", "-")

	return out
}

// FetchSpecsForConnConfig lookups all specs for region of conn config, and saves into TB spec objects
func FetchSpecsForConnConfig(connConfig string, nsId string) (specCount uint, err error) {
	fmt.Println("FetchSpecsForConnConfig(" + connConfig + ")")

	spiderSpecList, err := LookupSpecList(connConfig)
	if err != nil {
		common.CBLog.Error(err)
		return 0, err
	}

	for _, spiderSpec := range spiderSpecList.Vmspec {
		tumblebugSpec, err := ConvertSpiderSpecToTumblebugSpec(spiderSpec)
		if err != nil {
			common.CBLog.Error(err)
			return 0, err
		}

		tumblebugSpecId := connConfig + "-" + RefineSpecName(tumblebugSpec.Name)
		//fmt.Println("tumblebugSpecId: " + tumblebugSpecId) // for debug

		check, err := CheckResource(nsId, common.StrSpec, tumblebugSpecId)
		if check {
			common.CBLog.Infoln("The spec " + tumblebugSpecId + " already exists in TB; continue")
			continue
		} else if err != nil {
			common.CBLog.Infoln("Cannot check the existence of " + tumblebugSpecId + " in TB; continue")
			continue
		} else {
			tumblebugSpec.Name = tumblebugSpecId
			tumblebugSpec.ConnectionName = connConfig

			_, err := RegisterSpecWithInfo(nsId, &tumblebugSpec)
			if err != nil {
				common.CBLog.Error(err)
				return 0, err
			}
			specCount++
		}
	}
	return specCount, nil
}

// FetchSpecsForAllConnConfigs gets all conn configs from Spider, lookups all specs for each region of conn config, and saves into TB spec objects
func FetchSpecsForAllConnConfigs(nsId string) (connConfigCount uint, specCount uint, err error) {

	err = common.CheckString(nsId)
	if err != nil {
		common.CBLog.Error(err)
		return 0, 0, err
	}

	connConfigs, err := common.GetConnConfigList()
	if err != nil {
		common.CBLog.Error(err)
		return 0, 0, err
	}

	for _, connConfig := range connConfigs.Connectionconfig {
		temp, _ := FetchSpecsForConnConfig(connConfig.ConfigName, nsId)
		specCount += temp
		connConfigCount++
	}
	return connConfigCount, specCount, nil
}

// RegisterSpecWithCspSpecName accepts spec creation request, creates and returns an TB spec object
func RegisterSpecWithCspSpecName(nsId string, u *TbSpecReq) (TbSpecInfo, error) {

	resourceType := common.StrSpec

	err := common.CheckString(nsId)
	if err != nil {
		temp := TbSpecInfo{}
		common.CBLog.Error(err)
		return temp, err
	}

	// returns InvalidValidationError for bad validation input, nil or ValidationErrors ( []FieldError )
	err = validate.Struct(u)
	if err != nil {

		// this check is only needed when your code could produce
		// an invalid value for validation such as interface with nil
		// value most including myself do not usually have code like this.
		if _, ok := err.(*validator.InvalidValidationError); ok {
			fmt.Println(err)
			temp := TbSpecInfo{}
			return temp, err
		}

		// for _, err := range err.(validator.ValidationErrors) {

		// 	fmt.Println(err.Namespace()) // can differ when a custom TagNameFunc is registered or
		// 	fmt.Println(err.Field())     // by passing alt name to ReportError like below
		// 	fmt.Println(err.StructNamespace())
		// 	fmt.Println(err.StructField())
		// 	fmt.Println(err.Tag())
		// 	fmt.Println(err.ActualTag())
		// 	fmt.Println(err.Kind())
		// 	fmt.Println(err.Type())
		// 	fmt.Println(err.Value())
		// 	fmt.Println(err.Param())
		// 	fmt.Println()
		// }

		temp := TbSpecInfo{}
		return temp, err
	}

	check, err := CheckResource(nsId, resourceType, u.Name)

	if err != nil {
		temp := TbSpecInfo{}
		common.CBLog.Error(err)
		return temp, err
	}

	if check {
		temp := TbSpecInfo{}
		err := fmt.Errorf("The spec " + u.Name + " already exists.")
		return temp, err
	}

	res, err := LookupSpec(u.ConnectionName, u.CspSpecName)
	if err != nil {
		common.CBLog.Error(err)
		err := fmt.Errorf("an error occurred while lookup spec via CB-Spider")
		emptySpecInfoObj := TbSpecInfo{}
		return emptySpecInfoObj, err
	}

	content := TbSpecInfo{}
	content.Namespace = nsId
	//content.Id = common.GenUid()
	content.Id = u.Name
	content.Name = u.Name
	content.CspSpecName = res.Name
	content.ConnectionName = u.ConnectionName
	content.AssociatedObjectList = []string{}

	tempUint64, _ := strconv.ParseUint(res.VCpu.Count, 10, 16)
	content.NumvCPU = uint16(tempUint64)

	//content.Num_core = res.Num_core

	tempFloat64, _ := strconv.ParseFloat(res.Mem, 32)
	content.MemGiB = float32(tempFloat64 / 1024)

	//content.StorageGiB = res.StorageGiB
	//content.Description = res.Description

	// cb-store
	fmt.Println("=========================== PUT registerSpec")
	Key := common.GenResourceKey(nsId, resourceType, content.Id)
	Val, _ := json.Marshal(content)
	err = common.CBStore.Put(Key, string(Val))
	if err != nil {
		common.CBLog.Error(err)
		return content, err
	}
	keyValue, err := common.CBStore.Get(Key)
	if err != nil {
		fmt.Println("In RegisterSpecWithCspSpecName(); CBStore.Get() returned error.")
	}
	fmt.Println("<" + keyValue.Key + "> \n" + keyValue.Value)
	fmt.Println("===========================")

	// "INSERT INTO `spec`(`namespace`, `id`, ...) VALUES ('nsId', 'content.Id', ...);
	_, err = common.ORM.Insert(&content)
	if err != nil {
		fmt.Println(err.Error())
	} else {
		fmt.Println("Data inserted successfully..")
	}

	return content, nil
}

// RegisterSpecWithInfo accepts spec creation request, creates and returns an TB spec object
func RegisterSpecWithInfo(nsId string, content *TbSpecInfo) (TbSpecInfo, error) {

	resourceType := common.StrSpec

	err := common.CheckString(nsId)
	if err != nil {
		temp := TbSpecInfo{}
		common.CBLog.Error(err)
		return temp, err
	}
	err = common.CheckString(content.Name)
	if err != nil {
		temp := TbSpecInfo{}
		common.CBLog.Error(err)
		return temp, err
	}
	check, err := CheckResource(nsId, resourceType, content.Name)

	if err != nil {
		temp := TbSpecInfo{}
		common.CBLog.Error(err)
		return temp, err
	}

	if check {
		temp := TbSpecInfo{}
		err := fmt.Errorf("The spec " + content.Name + " already exists.")
		return temp, err
	}

	content.Namespace = nsId
	content.Id = content.Name
	content.AssociatedObjectList = []string{}

	// cb-store
	fmt.Println("=========================== PUT registerSpec")
	Key := common.GenResourceKey(nsId, resourceType, content.Id)
	Val, _ := json.Marshal(content)
	err = common.CBStore.Put(Key, string(Val))
	if err != nil {
		common.CBLog.Error(err)
		return *content, err
	}
	keyValue, err := common.CBStore.Get(Key)
	if err != nil {
		fmt.Println("In RegisterSpecWithInfo(); CBStore.Get() returned error.")
	}

	fmt.Println("<" + keyValue.Key + "> \n" + keyValue.Value)
	fmt.Println("===========================")

	// "INSERT INTO `spec`(`namespace`, `id`, ...) VALUES ('nsId', 'content.Id', ...);
	_, err = common.ORM.Insert(content)
	if err != nil {
		fmt.Println(err.Error())
	} else {
		fmt.Println("Data inserted successfully..")
	}

	return *content, nil
}

// FilterSpecs accepts criteria for filtering, and returns the list of filtered TB spec objects
func FilterSpecs(nsId string, filter TbSpecInfo) ([]TbSpecInfo, error) {

	err := common.CheckString(nsId)
	if err != nil {
		common.CBLog.Error(err)
		return nil, err
	}

	tempList := []TbSpecInfo{}

	//sqlQuery := "SELECT * FROM `spec` WHERE `namespace`='" + nsId + "'"
	sqlQuery := common.ORM.Where("Namespace = ?", nsId)

	if filter.Id != "" {
		//sqlQuery += " AND `id` LIKE '%" + filter.Id + "%'"
		filter.Id = RefineSpecName(filter.Id)
		sqlQuery = sqlQuery.And("Id LIKE ?", "%"+filter.Id+"%")
	}
	if filter.Name != "" {
		//sqlQuery += " AND `name` LIKE '%" + filter.Name + "%'"
		filter.Name = RefineSpecName(filter.Name)
		sqlQuery = sqlQuery.And("Name LIKE ?", "%"+filter.Name+"%")
	}
	if filter.ConnectionName != "" {
		//sqlQuery += " AND `connectionName` LIKE '%" + filter.ConnectionName + "%'"
		filter.ConnectionName = RefineSpecName(filter.ConnectionName)
		sqlQuery = sqlQuery.And("ConnectionName LIKE ?", "%"+filter.ConnectionName+"%")
	}
	if filter.CspSpecName != "" {
		//sqlQuery += " AND `cspSpecName` LIKE '%" + filter.CspSpecName + "%'"
		filter.CspSpecName = RefineSpecName(filter.CspSpecName)
		sqlQuery = sqlQuery.And("CspSpecName LIKE ?", "%"+filter.CspSpecName+"%")
	}
	if filter.OsType != "" {
		//sqlQuery += " AND `osType` LIKE '%" + filter.OsType + "%'"
		filter.OsType = RefineSpecName(filter.OsType)
		sqlQuery = sqlQuery.And("OsType LIKE ?", "%"+filter.OsType+"%")
	}

	if filter.NumvCPU > 0 {
		//sqlQuery += " AND `numvCPU`=" + strconv.Itoa(int(filter.NumvCPU))
		sqlQuery = sqlQuery.And("NumvCPU = ?", filter.NumvCPU)
	}
	if filter.NumCore > 0 {
		//sqlQuery += " AND `numCore`=" + strconv.Itoa(int(filter.NumCore))
		sqlQuery = sqlQuery.And("NumCore = ?", filter.NumCore)
	}
	if filter.MemGiB > 0 {
		//sqlQuery += " AND `memGiB`=" + strconv.Itoa(int(filter.MemGiB))
		sqlQuery = sqlQuery.And("MemGiB = ?", filter.MemGiB)
	}
	if filter.StorageGiB > 0 {
		//sqlQuery += " AND `storageGiB`=" + strconv.Itoa(int(filter.StorageGiB))
		sqlQuery = sqlQuery.And("StorageGiB = ?", filter.StorageGiB)
	}
	if filter.Description != "" {
		//sqlQuery += " AND `description` LIKE '%" + filter.Description + "%'"
		filter.Description = RefineSpecName(filter.Description)
		sqlQuery = sqlQuery.And("Description LIKE ?", "%"+filter.Description+"%")
	}
	if filter.CostPerHour > 0 {
		//sqlQuery += " AND `costPerHour`=" + fmt.Sprintf("%.6f", filter.CostPerHour)
		sqlQuery = sqlQuery.And("CostPerHour = ?", filter.CostPerHour)
	}
	if filter.NumStorage > 0 {
		//sqlQuery += " AND `numStorage`=" + strconv.Itoa(int(filter.NumStorage))
		sqlQuery = sqlQuery.And("NumStorage = ?", filter.NumStorage)
	}
	if filter.MaxNumStorage > 0 {
		//sqlQuery += " AND `maxNumStorage`=" + strconv.Itoa(int(filter.MaxNumStorage))
		sqlQuery = sqlQuery.And("MaxNumStorage = ?", filter.MaxNumStorage)
	}
	if filter.MaxTotalStorageTiB > 0 {
		//sqlQuery += " AND `maxTotalStorageTiB`=" + strconv.Itoa(int(filter.MaxTotalStorageTiB))
		sqlQuery = sqlQuery.And("MaxTotalStorageTiB = ?", filter.MaxTotalStorageTiB)
	}
	if filter.NetBwGbps > 0 {
		//sqlQuery += " AND `netBwGbps`=" + strconv.Itoa(int(filter.NetBwGbps))
		sqlQuery = sqlQuery.And("NetBwGbps = ?", filter.NetBwGbps)
	}
	if filter.EbsBwMbps > 0 {
		//sqlQuery += " AND `ebsBwMbps`=" + strconv.Itoa(int(filter.EbsBwMbps))
		sqlQuery = sqlQuery.And("EbsBwMbps = ?", filter.EbsBwMbps)
	}
	if filter.GpuModel != "" {
		//sqlQuery += " AND `gpuModel` LIKE '%" + filter.GpuModel + "%'"
		filter.GpuModel = RefineSpecName(filter.GpuModel)
		sqlQuery = sqlQuery.And("GpuModel LIKE ?", "%"+filter.GpuModel+"%")
	}
	if filter.NumGpu > 0 {
		//sqlQuery += " AND `numGpu`=" + strconv.Itoa(int(filter.NumGpu))
		sqlQuery = sqlQuery.And("NumGpu = ?", filter.NumGpu)
	}
	if filter.GpuMemGiB > 0 {
		//sqlQuery += " AND `gpuMemGiB`=" + strconv.Itoa(int(filter.GpuMemGiB))
		sqlQuery = sqlQuery.And("GpuMemGiB = ?", filter.GpuMemGiB)
	}
	if filter.GpuP2p != "" {
		//sqlQuery += " AND `gpuP2p` LIKE '%" + filter.GpuP2p + "%'"
		filter.GpuP2p = RefineSpecName(filter.GpuP2p)
		sqlQuery = sqlQuery.And("GpuP2p LIKE ?", "%"+filter.GpuP2p+"%")
	}
	if filter.EvaluationStatus != "" {
		//sqlQuery += " AND `evaluationStatus` LIKE '%" + filter.EvaluationStatus + "%'"
		filter.EvaluationStatus = RefineSpecName(filter.EvaluationStatus)
		sqlQuery = sqlQuery.And("EvaluationStatus LIKE ?", "%"+filter.EvaluationStatus+"%")
	}
	if filter.EvaluationScore01 > 0 {
		//sqlQuery += " AND `evaluationScore01`=" + fmt.Sprintf("%.6f", filter.EvaluationScore01)
		sqlQuery = sqlQuery.And("EvaluationScore01 = ?", filter.EvaluationScore01)
	}
	if filter.EvaluationScore02 > 0 {
		//sqlQuery += " AND `evaluationScore02`=" + fmt.Sprintf("%.6f", filter.EvaluationScore02)
		sqlQuery = sqlQuery.And("EvaluationScore02 = ?", filter.EvaluationScore02)
	}
	if filter.EvaluationScore03 > 0 {
		//sqlQuery += " AND `evaluationScore03`=" + fmt.Sprintf("%.6f", filter.EvaluationScore03)
		sqlQuery = sqlQuery.And("EvaluationScore03 = ?", filter.EvaluationScore03)
	}
	if filter.EvaluationScore04 > 0 {
		//sqlQuery += " AND `evaluationScore04`=" + fmt.Sprintf("%.6f", filter.EvaluationScore04)
		sqlQuery = sqlQuery.And("EvaluationScore04 = ?", filter.EvaluationScore04)
	}
	if filter.EvaluationScore05 > 0 {
		//sqlQuery += " AND `evaluationScore05`=" + fmt.Sprintf("%.6f", filter.EvaluationScore05)
		sqlQuery = sqlQuery.And("EvaluationScore05 = ?", filter.EvaluationScore05)
	}
	if filter.EvaluationScore06 > 0 {
		//sqlQuery += " AND `evaluationScore06`=" + fmt.Sprintf("%.6f", filter.EvaluationScore06)
		sqlQuery = sqlQuery.And("EvaluationScore06 = ?", filter.EvaluationScore06)
	}
	if filter.EvaluationScore07 > 0 {
		//sqlQuery += " AND `evaluationScore07`=" + fmt.Sprintf("%.6f", filter.EvaluationScore07)
		sqlQuery = sqlQuery.And("EvaluationScore07 = ?", filter.EvaluationScore07)
	}
	if filter.EvaluationScore08 > 0 {
		//sqlQuery += " AND `evaluationScore08`=" + fmt.Sprintf("%.6f", filter.EvaluationScore08)
		sqlQuery = sqlQuery.And("EvaluationScore08 = ?", filter.EvaluationScore08)
	}
	if filter.EvaluationScore09 > 0 {
		//sqlQuery += " AND `evaluationScore09`=" + fmt.Sprintf("%.6f", filter.EvaluationScore09)
		sqlQuery = sqlQuery.And("EvaluationScore09 = ?", filter.EvaluationScore09)
	}
	if filter.EvaluationScore10 > 0 {
		//sqlQuery += " AND `evaluationScore10`=" + fmt.Sprintf("%.6f", filter.EvaluationScore10)
		sqlQuery = sqlQuery.And("EvaluationScore10 = ?", filter.EvaluationScore10)
	}

	err = sqlQuery.Find(&tempList)
	if err != nil {
		common.CBLog.Error(err)
		return tempList, err
	}
	return tempList, nil
}

type Range struct {
	Min float32 `json:"min"`
	Max float32 `json:"max"`
}

type FilterSpecsByRangeRequest struct {
	Id                 string `json:"id"`
	Name               string `json:"name"`
	ConnectionName     string `json:"connectionName"`
	CspSpecName        string `json:"cspSpecName"`
	OsType             string `json:"osType"`
	NumvCPU            Range  `json:"numvCPU"`
	NumCore            Range  `json:"numcore"`
	MemGiB             Range  `json:"memGiB"`
	StorageGiB         Range  `json:"storageGiB"`
	Description        string `json:"description"`
	CostPerHour        Range  `json:"costPerHour"`
	NumStorage         Range  `json:"numStorage"`
	MaxNumStorage      Range  `json:"maxNumStorage"`
	MaxTotalStorageTiB Range  `json:"maxTotalStorageTiB"`
	NetBwGbps          Range  `json:"netBwGbps"`
	EbsBwMbps          Range  `json:"ebsBwMbps"`
	GpuModel           string `json:"gpuModel"`
	NumGpu             Range  `json:"numGpu"`
	GpuMemGiB          Range  `json:"gpuMemGiB"`
	GpuP2p             string `json:"gpuP2p"`
	EvaluationStatus   string `json:"evaluationStatus"`
	EvaluationScore01  Range  `json:"evaluationScore01"`
	EvaluationScore02  Range  `json:"evaluationScore02"`
	EvaluationScore03  Range  `json:"evaluationScore03"`
	EvaluationScore04  Range  `json:"evaluationScore04"`
	EvaluationScore05  Range  `json:"evaluationScore05"`
	EvaluationScore06  Range  `json:"evaluationScore06"`
	EvaluationScore07  Range  `json:"evaluationScore07"`
	EvaluationScore08  Range  `json:"evaluationScore08"`
	EvaluationScore09  Range  `json:"evaluationScore09"`
	EvaluationScore10  Range  `json:"evaluationScore10"`
}

// FilterSpecsByRange accepts criteria ranges for filtering, and returns the list of filtered TB spec objects
func FilterSpecsByRange(nsId string, filter FilterSpecsByRangeRequest) ([]TbSpecInfo, error) {

	err := common.CheckString(nsId)
	if err != nil {
		common.CBLog.Error(err)
		return nil, err
	}

	tempList := []TbSpecInfo{}

	//sqlQuery := "SELECT * FROM `spec` WHERE `namespace`='" + nsId + "'"
	sqlQuery := common.ORM.Where("Namespace = ?", nsId)

	if filter.Id != "" {
		//sqlQuery += " AND `id` LIKE '%" + filter.Id + "%'"
		filter.Id = RefineSpecName(filter.Id)
		sqlQuery = sqlQuery.And("Id LIKE ?", "%"+filter.Id+"%")
	}
	if filter.Name != "" {
		//sqlQuery += " AND `name` LIKE '%" + filter.Name + "%'"
		filter.Name = RefineSpecName(filter.Name)
		sqlQuery = sqlQuery.And("Name LIKE ?", "%"+filter.Name+"%")
	}
	if filter.ConnectionName != "" {
		//sqlQuery += " AND `connectionName` LIKE '%" + filter.ConnectionName + "%'"
		filter.ConnectionName = RefineSpecName(filter.ConnectionName)
		sqlQuery = sqlQuery.And("ConnectionName LIKE ?", "%"+filter.ConnectionName+"%")
	}
	if filter.CspSpecName != "" {
		//sqlQuery += " AND `cspSpecName` LIKE '%" + filter.CspSpecName + "%'"
		filter.CspSpecName = RefineSpecName(filter.CspSpecName)
		sqlQuery = sqlQuery.And("CspSpecName LIKE ?", "%"+filter.CspSpecName+"%")
	}
	if filter.OsType != "" {
		//sqlQuery += " AND `osType` LIKE '%" + filter.OsType + "%'"
		filter.OsType = RefineSpecName(filter.OsType)
		sqlQuery = sqlQuery.And("OsType LIKE ?", "%"+filter.OsType+"%")
	}

	if filter.NumvCPU.Min > 0 {
		//sqlQuery += " AND `NumvCPU`>=" + fmt.Sprintf("%.6f", filter.NumvCPU.Min)
		sqlQuery = sqlQuery.And("NumvCPU >= ?", filter.NumvCPU.Min)
	}
	if filter.NumvCPU.Max > 0 {
		//sqlQuery += " AND `NumvCPU`<=" + fmt.Sprintf("%.6f", filter.NumvCPU.Max)
		sqlQuery = sqlQuery.And("NumvCPU <= ?", filter.NumvCPU.Max)
	}

	if filter.NumCore.Min > 0 {
		//sqlQuery += " AND `NumCore`>=" + fmt.Sprintf("%.6f", filter.NumCore.Min)
		sqlQuery = sqlQuery.And("NumCore >= ?", filter.NumCore.Min)
	}
	if filter.NumCore.Max > 0 {
		//sqlQuery += " AND `NumCore`<=" + fmt.Sprintf("%.6f", filter.NumCore.Max)
		sqlQuery = sqlQuery.And("NumCore <= ?", filter.NumCore.Max)
	}

	if filter.MemGiB.Min > 0 {
		//sqlQuery += " AND `MemGiB`>=" + fmt.Sprintf("%.6f", filter.MemGiB.Min)
		sqlQuery = sqlQuery.And("MemGiB >= ?", filter.MemGiB.Min)
	}
	if filter.MemGiB.Max > 0 {
		//sqlQuery += " AND `MemGiB`<=" + fmt.Sprintf("%.6f", filter.MemGiB.Max)
		sqlQuery = sqlQuery.And("MemGiB <= ?", filter.MemGiB.Max)
	}

	if filter.StorageGiB.Min > 0 {
		//sqlQuery += " AND `StorageGiB`>=" + fmt.Sprintf("%.6f", filter.StorageGiB.Min)
		sqlQuery = sqlQuery.And("StorageGiB >= ?", filter.StorageGiB.Min)
	}
	if filter.StorageGiB.Max > 0 {
		//sqlQuery += " AND `StorageGiB`<=" + fmt.Sprintf("%.6f", filter.StorageGiB.Max)
		sqlQuery = sqlQuery.And("StorageGiB <= ?", filter.StorageGiB.Max)
	}

	if filter.Description != "" {
		//sqlQuery += " AND `description` LIKE '%" + filter.Description + "%'"
		filter.Description = RefineSpecName(filter.Description)
		sqlQuery = sqlQuery.And("Description LIKE ?", "%"+filter.Description+"%")
	}

	if filter.CostPerHour.Min > 0 {
		//sqlQuery += " AND `CostPerHour`>=" + fmt.Sprintf("%.6f", filter.CostPerHour.Min)
		sqlQuery = sqlQuery.And("CostPerHour >= ?", filter.CostPerHour.Min)
	}
	if filter.CostPerHour.Max > 0 {
		//sqlQuery += " AND `CostPerHour`<=" + fmt.Sprintf("%.6f", filter.CostPerHour.Max)
		sqlQuery = sqlQuery.And("CostPerHour <= ?", filter.CostPerHour.Max)
	}

	if filter.NumStorage.Min > 0 {
		//sqlQuery += " AND `num_storage`>=" + fmt.Sprintf("%.6f", filter.Num_storage.Min)
		sqlQuery = sqlQuery.And("NumStorage >= ?", filter.NumStorage.Min)
	}
	if filter.NumStorage.Max > 0 {
		//sqlQuery += " AND `NumStorage`<=" + fmt.Sprintf("%.6f", filter.NumStorage.Max)
		sqlQuery = sqlQuery.And("NumStorage <= ?", filter.NumStorage.Max)
	}

	if filter.MaxNumStorage.Min > 0 {
		//sqlQuery += " AND `MaxNumStorage`>=" + fmt.Sprintf("%.6f", filter.MaxNumStorage.Min)
		sqlQuery = sqlQuery.And("MaxNumStorage >= ?", filter.MaxNumStorage.Min)
	}
	if filter.MaxNumStorage.Max > 0 {
		//sqlQuery += " AND `MaxNumStorage`<=" + fmt.Sprintf("%.6f", filter.MaxNumStorage.Max)
		sqlQuery = sqlQuery.And("MaxNumStorage <= ?", filter.MaxNumStorage.Max)
	}

	if filter.MaxTotalStorageTiB.Min > 0 {
		//sqlQuery += " AND `MaxTotalStorageTiB`>=" + fmt.Sprintf("%.6f", filter.MaxTotalStorageTiB.Min)
		sqlQuery = sqlQuery.And("MaxTotalStorageTiB >= ?", filter.MaxTotalStorageTiB.Min)
	}
	if filter.MaxTotalStorageTiB.Max > 0 {
		//sqlQuery += " AND `MaxTotalStorageTiB`<=" + fmt.Sprintf("%.6f", filter.MaxTotalStorageTiB.Max)
		sqlQuery = sqlQuery.And("MaxTotalStorageTiB <= ?", filter.MaxTotalStorageTiB.Max)
	}

	if filter.NetBwGbps.Min > 0 {
		//sqlQuery += " AND `NetBwGbps`>=" + fmt.Sprintf("%.6f", filter.NetBwGbps.Min)
		sqlQuery = sqlQuery.And("NetBwGbps >= ?", filter.NetBwGbps.Min)
	}
	if filter.NetBwGbps.Max > 0 {
		//sqlQuery += " AND `NetBwGbps`<=" + fmt.Sprintf("%.6f", filter.NetBwGbps.Max)
		sqlQuery = sqlQuery.And("NetBwGbps <= ?", filter.NetBwGbps.Max)
	}

	if filter.EbsBwMbps.Min > 0 {
		//sqlQuery += " AND `EbsBwMbps`>=" + fmt.Sprintf("%.6f", filter.EbsBwMbps.Min)
		sqlQuery = sqlQuery.And("EbsBwMbps >= ?", filter.EbsBwMbps.Min)
	}
	if filter.EbsBwMbps.Max > 0 {
		//sqlQuery += " AND `EbsBwMbps`<=" + fmt.Sprintf("%.6f", filter.EbsBwMbps.Max)
		sqlQuery = sqlQuery.And("EbsBwMbps <= ?", filter.EbsBwMbps.Max)
	}

	if filter.GpuModel != "" {
		//sqlQuery += " AND `GpuModel` LIKE '%" + filter.GpuModel + "%'"
		filter.GpuModel = RefineSpecName(filter.GpuModel)
		sqlQuery = sqlQuery.And("GpuModel LIKE ?", "%"+filter.GpuModel+"%")
	}

	if filter.NumGpu.Min > 0 {
		//sqlQuery += " AND `NumGpu`>=" + fmt.Sprintf("%.6f", filter.NumGpu.Min)
		sqlQuery = sqlQuery.And("NumGpu >= ?", filter.NumGpu.Min)
	}
	if filter.NumGpu.Max > 0 {
		//sqlQuery += " AND `NumGpu`<=" + fmt.Sprintf("%.6f", filter.NumGpu.Max)
		sqlQuery = sqlQuery.And("NumGpu <= ?", filter.NumGpu.Max)
	}

	if filter.GpuMemGiB.Min > 0 {
		//sqlQuery += " AND `GpuMemGiB`>=" + fmt.Sprintf("%.6f", filter.GpuMemGiB.Min)
		sqlQuery = sqlQuery.And("GpuMemGiB >= ?", filter.GpuMemGiB.Min)
	}
	if filter.GpuMemGiB.Max > 0 {
		//sqlQuery += " AND `GpuMemGiB`<=" + fmt.Sprintf("%.6f", filter.GpuMemGiB.Max)
		sqlQuery = sqlQuery.And("GpuMemGiB <= ?", filter.GpuMemGiB.Max)
	}

	if filter.GpuP2p != "" {
		//sqlQuery += " AND `GpuP2p` LIKE '%" + filter.GpuP2p + "%'"
		filter.GpuP2p = RefineSpecName(filter.GpuP2p)
		sqlQuery = sqlQuery.And("GpuP2p LIKE ?", "%"+filter.GpuP2p+"%")
	}
	if filter.EvaluationStatus != "" {
		//sqlQuery += " AND `evaluationStatus` LIKE '%" + filter.EvaluationStatus + "%'"
		filter.EvaluationStatus = RefineSpecName(filter.EvaluationStatus)
		sqlQuery = sqlQuery.And("EvaluationStatus LIKE ?", "%"+filter.EvaluationStatus+"%")
	}

	if filter.EvaluationScore01.Min > 0 {
		//sqlQuery += " AND `evaluationScore01`>=" + fmt.Sprintf("%.6f", filter.EvaluationScore01.Min)
		sqlQuery = sqlQuery.And("EvaluationScore01 >= ?", filter.EvaluationScore01.Min)
	}
	if filter.EvaluationScore01.Max > 0 {
		//sqlQuery += " AND `evaluationScore01`<=" + fmt.Sprintf("%.6f", filter.EvaluationScore01.Max)
		sqlQuery = sqlQuery.And("EvaluationScore01 <= ?", filter.EvaluationScore01.Max)
	}

	if filter.EvaluationScore02.Min > 0 {
		//sqlQuery += " AND `evaluationScore02`>=" + fmt.Sprintf("%.6f", filter.EvaluationScore02.Min)
		sqlQuery = sqlQuery.And("EvaluationScore02 >= ?", filter.EvaluationScore02.Min)
	}
	if filter.EvaluationScore02.Max > 0 {
		//sqlQuery += " AND `evaluationScore02`<=" + fmt.Sprintf("%.6f", filter.EvaluationScore02.Max)
		sqlQuery = sqlQuery.And("EvaluationScore02 <= ?", filter.EvaluationScore02.Max)
	}

	if filter.EvaluationScore03.Min > 0 {
		//sqlQuery += " AND `evaluationScore03`>=" + fmt.Sprintf("%.6f", filter.EvaluationScore03.Min)
		sqlQuery = sqlQuery.And("EvaluationScore03 >= ?", filter.EvaluationScore03.Min)
	}
	if filter.EvaluationScore03.Max > 0 {
		//sqlQuery += " AND `evaluationScore03`<=" + fmt.Sprintf("%.6f", filter.EvaluationScore03.Max)
		sqlQuery = sqlQuery.And("EvaluationScore03 <= ?", filter.EvaluationScore03.Max)
	}

	if filter.EvaluationScore04.Min > 0 {
		//sqlQuery += " AND `evaluationScore04`>=" + fmt.Sprintf("%.6f", filter.EvaluationScore04.Min)
		sqlQuery = sqlQuery.And("EvaluationScore04 >= ?", filter.EvaluationScore04.Min)
	}
	if filter.EvaluationScore04.Max > 0 {
		//sqlQuery += " AND `evaluationScore04`<=" + fmt.Sprintf("%.6f", filter.EvaluationScore04.Max)
		sqlQuery = sqlQuery.And("EvaluationScore04 <= ?", filter.EvaluationScore04.Max)
	}

	if filter.EvaluationScore05.Min > 0 {
		//sqlQuery += " AND `evaluationScore05`>=" + fmt.Sprintf("%.6f", filter.EvaluationScore05.Min)
		sqlQuery = sqlQuery.And("EvaluationScore05 >= ?", filter.EvaluationScore05.Min)
	}
	if filter.EvaluationScore05.Max > 0 {
		//sqlQuery += " AND `evaluationScore05`<=" + fmt.Sprintf("%.6f", filter.EvaluationScore05.Max)
		sqlQuery = sqlQuery.And("EvaluationScore05 <= ?", filter.EvaluationScore05.Max)
	}

	if filter.EvaluationScore06.Min > 0 {
		//sqlQuery += " AND `evaluationScore06`>=" + fmt.Sprintf("%.6f", filter.EvaluationScore06.Min)
		sqlQuery = sqlQuery.And("EvaluationScore06 >= ?", filter.EvaluationScore06.Min)
	}
	if filter.EvaluationScore06.Max > 0 {
		//sqlQuery += " AND `evaluationScore06`<=" + fmt.Sprintf("%.6f", filter.EvaluationScore06.Max)
		sqlQuery = sqlQuery.And("EvaluationScore06 <= ?", filter.EvaluationScore06.Max)
	}

	if filter.EvaluationScore07.Min > 0 {
		//sqlQuery += " AND `evaluationScore07`>=" + fmt.Sprintf("%.6f", filter.EvaluationScore07.Min)
		sqlQuery = sqlQuery.And("EvaluationScore07 >= ?", filter.EvaluationScore07.Min)
	}
	if filter.EvaluationScore07.Max > 0 {
		//sqlQuery += " AND `evaluationScore07`<=" + fmt.Sprintf("%.6f", filter.EvaluationScore07.Max)
		sqlQuery = sqlQuery.And("EvaluationScore07 <= ?", filter.EvaluationScore07.Max)
	}

	if filter.EvaluationScore08.Min > 0 {
		//sqlQuery += " AND `evaluationScore08`>=" + fmt.Sprintf("%.6f", filter.EvaluationScore08.Min)
		sqlQuery = sqlQuery.And("EvaluationScore08 >= ?", filter.EvaluationScore08.Min)
	}
	if filter.EvaluationScore08.Max > 0 {
		//sqlQuery += " AND `evaluationScore08`<=" + fmt.Sprintf("%.6f", filter.EvaluationScore08.Max)
		sqlQuery = sqlQuery.And("EvaluationScore08 <= ?", filter.EvaluationScore08.Max)
	}

	if filter.EvaluationScore09.Min > 0 {
		//sqlQuery += " AND `evaluationScore09`>=" + fmt.Sprintf("%.6f", filter.EvaluationScore09.Min)
		sqlQuery = sqlQuery.And("EvaluationScore09 >= ?", filter.EvaluationScore09.Min)
	}
	if filter.EvaluationScore09.Max > 0 {
		//sqlQuery += " AND `evaluationScore09`<=" + fmt.Sprintf("%.6f", filter.EvaluationScore09.Max)
		sqlQuery = sqlQuery.And("EvaluationScore09 <= ?", filter.EvaluationScore09.Max)
	}

	if filter.EvaluationScore10.Min > 0 {
		//sqlQuery += " AND `evaluationScore10`>=" + fmt.Sprintf("%.6f", filter.EvaluationScore10.Min)
		sqlQuery = sqlQuery.And("EvaluationScore10 >= ?", filter.EvaluationScore10.Min)
	}
	if filter.EvaluationScore10.Max > 0 {
		//sqlQuery += " AND `evaluationScore10`<=" + fmt.Sprintf("%.6f", filter.EvaluationScore10.Max)
		sqlQuery = sqlQuery.And("EvaluationScore10 <= ?", filter.EvaluationScore10.Max)
	}

	err = sqlQuery.Find(&tempList)
	if err != nil {
		common.CBLog.Error(err)
		return tempList, err
	}

	return tempList, nil
}

// SortSpecs accepts the list of TB spec objects, criteria and sorting direction,
// sorts and returns the sorted list of TB spec objects
func SortSpecs(specList []TbSpecInfo, orderBy string, direction string) ([]TbSpecInfo, error) {
	var err error = nil

	sort.Slice(specList, func(i, j int) bool {
		if orderBy == "numvCPU" {
			if direction == "descending" {
				return specList[i].NumvCPU > specList[j].NumvCPU
			} else if direction == "ascending" {
				return specList[i].NumvCPU < specList[j].NumvCPU
			} else {
				err = fmt.Errorf("'direction' should one of these: ascending, descending")
				return true
			}
		} else if orderBy == "memGiB" {
			if direction == "descending" {
				return specList[i].MemGiB > specList[j].MemGiB
			} else if direction == "ascending" {
				return specList[i].MemGiB < specList[j].MemGiB
			} else {
				err = fmt.Errorf("'direction' should one of these: ascending, descending")
				return true
			}
		} else if orderBy == "storageGiB" {
			if direction == "descending" {
				return specList[i].StorageGiB > specList[j].StorageGiB
			} else if direction == "ascending" {
				return specList[i].StorageGiB < specList[j].StorageGiB
			} else {
				err = fmt.Errorf("'direction' should one of these: ascending, descending")
				return true
			}
		} else if orderBy == "evaluationScore01" {
			if direction == "descending" {
				return specList[i].EvaluationScore01 > specList[j].EvaluationScore01
			} else if direction == "ascending" {
				return specList[i].EvaluationScore01 < specList[j].EvaluationScore01
			} else {
				err = fmt.Errorf("'direction' should one of these: ascending, descending")
				return true
			}
		} else if orderBy == "evaluationScore02" {
			if direction == "descending" {
				return specList[i].EvaluationScore02 > specList[j].EvaluationScore02
			} else if direction == "ascending" {
				return specList[i].EvaluationScore02 < specList[j].EvaluationScore02
			} else {
				err = fmt.Errorf("'direction' should one of these: ascending, descending")
				return true
			}
		} else if orderBy == "evaluationScore03" {
			if direction == "descending" {
				return specList[i].EvaluationScore03 > specList[j].EvaluationScore03
			} else if direction == "ascending" {
				return specList[i].EvaluationScore03 < specList[j].EvaluationScore03
			} else {
				err = fmt.Errorf("'direction' should one of these: ascending, descending")
				return true
			}
		} else if orderBy == "evaluationScore04" {
			if direction == "descending" {
				return specList[i].EvaluationScore04 > specList[j].EvaluationScore04
			} else if direction == "ascending" {
				return specList[i].EvaluationScore04 < specList[j].EvaluationScore04
			} else {
				err = fmt.Errorf("'direction' should one of these: ascending, descending")
				return true
			}
		} else if orderBy == "evaluationScore05" {
			if direction == "descending" {
				return specList[i].EvaluationScore05 > specList[j].EvaluationScore05
			} else if direction == "ascending" {
				return specList[i].EvaluationScore05 < specList[j].EvaluationScore05
			} else {
				err = fmt.Errorf("'direction' should one of these: ascending, descending")
				return true
			}
		} else if orderBy == "evaluationScore06" {
			if direction == "descending" {
				return specList[i].EvaluationScore06 > specList[j].EvaluationScore06
			} else if direction == "ascending" {
				return specList[i].EvaluationScore06 < specList[j].EvaluationScore06
			} else {
				err = fmt.Errorf("'direction' should one of these: ascending, descending")
				return true
			}
		} else if orderBy == "evaluationScore07" {
			if direction == "descending" {
				return specList[i].EvaluationScore07 > specList[j].EvaluationScore07
			} else if direction == "ascending" {
				return specList[i].EvaluationScore07 < specList[j].EvaluationScore07
			} else {
				err = fmt.Errorf("'direction' should one of these: ascending, descending")
				return true
			}
		} else if orderBy == "evaluationScore08" {
			if direction == "descending" {
				return specList[i].EvaluationScore08 > specList[j].EvaluationScore08
			} else if direction == "ascending" {
				return specList[i].EvaluationScore08 < specList[j].EvaluationScore08
			} else {
				err = fmt.Errorf("'direction' should one of these: ascending, descending")
				return true
			}
		} else if orderBy == "evaluationScore09" {
			if direction == "descending" {
				return specList[i].EvaluationScore09 > specList[j].EvaluationScore09
			} else if direction == "ascending" {
				return specList[i].EvaluationScore09 < specList[j].EvaluationScore09
			} else {
				err = fmt.Errorf("'direction' should one of these: ascending, descending")
				return true
			}
		} else if orderBy == "evaluationScore10" {
			if direction == "descending" {
				return specList[i].EvaluationScore10 > specList[j].EvaluationScore10
			} else if direction == "ascending" {
				return specList[i].EvaluationScore10 < specList[j].EvaluationScore10
			} else {
				err = fmt.Errorf("'direction' should one of these: ascending, descending")
				return true
			}
		} else {
			err = fmt.Errorf("'orderBy' should one of these: numvCPU, memGiB, storageGiB")
			return true
		}
	})

	for i := range specList {
		specList[i].OrderInFilteredResult = uint16(i + 1)
	}

	return specList, err
}

// UpdateSpec accepts to-be TB spec objects,
// updates and returns the updated TB spec objects
func UpdateSpec(nsId string, specId string, fieldsToUpdate TbSpecInfo) (TbSpecInfo, error) {
	resourceType := common.StrSpec

	err := common.CheckString(nsId)
	if err != nil {
		temp := TbSpecInfo{}
		common.CBLog.Error(err)
		return temp, err
	}

	if len(fieldsToUpdate.Namespace) > 0 {
		temp := TbSpecInfo{}
		err := fmt.Errorf("You should not specify 'namespace' in the JSON request body.")
		common.CBLog.Error(err)
		return temp, err
	}

	if len(fieldsToUpdate.Id) > 0 {
		temp := TbSpecInfo{}
		err := fmt.Errorf("You should not specify 'id' in the JSON request body.")
		common.CBLog.Error(err)
		return temp, err
	}

	check, err := CheckResource(nsId, resourceType, specId)

	if err != nil {
		temp := TbSpecInfo{}
		common.CBLog.Error(err)
		return temp, err
	}

	if !check {
		temp := TbSpecInfo{}
		err := fmt.Errorf("The spec " + specId + " does not exist.")
		return temp, err
	}

	tempInterface, err := GetResource(nsId, resourceType, specId)
	if err != nil {
		temp := TbSpecInfo{}
		err := fmt.Errorf("Failed to get the spec " + specId + ".")
		return temp, err
	}
	asIsSpec := TbSpecInfo{}
	err = common.CopySrcToDest(&tempInterface, &asIsSpec)
	if err != nil {
		temp := TbSpecInfo{}
		err := fmt.Errorf("Failed to CopySrcToDest() " + specId + ".")
		return temp, err
	}

	// Update specified fields only
	toBeSpec := asIsSpec
	toBeSpecJSON, _ := json.Marshal(fieldsToUpdate)
	err = json.Unmarshal(toBeSpecJSON, &toBeSpec)

	// cb-store
	fmt.Println("=========================== PUT UpdateSpec")
	Key := common.GenResourceKey(nsId, resourceType, toBeSpec.Id)
	Val, _ := json.Marshal(toBeSpec)
	err = common.CBStore.Put(Key, string(Val))
	if err != nil {
		temp := TbSpecInfo{}
		common.CBLog.Error(err)
		return temp, err
	}
	keyValue, err := common.CBStore.Get(Key)
	if err != nil {
		common.CBLog.Error(err)
		err = fmt.Errorf("In UpdateSpec(); CBStore.Get() returned an error.")
		common.CBLog.Error(err)
		// return nil, err
	}

	fmt.Println("<" + keyValue.Key + "> \n" + keyValue.Value)
	fmt.Println("===========================")

	// "UPDATE `spec` SET `id`='" + specId + "', ... WHERE `namespace`='" + nsId + "' AND `id`='" + specId + "';"
	_, err = common.ORM.Update(&toBeSpec, &TbSpecInfo{Namespace: nsId, Id: specId})
	if err != nil {
		fmt.Println(err.Error())
	} else {
		fmt.Println("SQL data updated successfully..")
	}

	return toBeSpec, nil
}

// deprecated
// // RegisterRecommendList creates the spec recommendation info
// func RegisterRecommendList(nsId string, connectionName string, cpuSize uint16, memSize float32, diskSize uint32, specId string, price float32) error {

// 	err := common.CheckString(nsId)
// 	if err != nil {
// 		common.CBLog.Error(err)
// 		return err
// 	}

// 	//fmt.Println("[Get MCISs")
// 	key := common.GenMcisKey(nsId, "", "") + "/cpuSize/" + strconv.Itoa(int(cpuSize)) + "/memSize/" + strconv.Itoa(int(memSize)) + "/diskSize/" + strconv.Itoa(int(diskSize)) + "/specId/" + specId
// 	fmt.Println(key)

// 	mapA := map[string]string{"id": specId, "price": fmt.Sprintf("%.6f", price), "connectionName": connectionName}
// 	Val, _ := json.Marshal(mapA)

// 	err = common.CBStore.Put(key, string(Val))
// 	if err != nil {
// 		common.CBLog.Error(err)
// 		return err
// 	}

// 	fmt.Println("===============================================")
// 	return nil

// }

// deprecated
// // DelRecommendSpec deletes the spec recommendation info
// func DelRecommendSpec(nsId string, specId string, cpuSize uint16, memSize float32, diskSize uint32) error {

// 	err := common.CheckString(nsId)
// 	if err != nil {
// 		common.CBLog.Error(err)
// 		return err
// 	}

// 	fmt.Println("DelRecommendSpec()")

// 	key := common.GenMcisKey(nsId, "", "") + "/cpuSize/" + strconv.Itoa(int(cpuSize)) + "/memSize/" + strconv.Itoa(int(memSize)) + "/diskSize/" + strconv.Itoa(int(diskSize)) + "/specId/" + specId

// 	err = common.CBStore.Delete(key)
// 	if err != nil {
// 		common.CBLog.Error(err)
// 		return err
// 	}

// 	return nil

// }
